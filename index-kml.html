<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TileIQ - Tile selection tool</title>
    <link href='https://unpkg.com/maplibre-gl@4.1.0/dist/maplibre-gl.css' rel='stylesheet' />
    <script src='https://unpkg.com/maplibre-gl@4.1.0/dist/maplibre-gl.js'></script>
    <style>
        /* Basic styling */
        html, body {
            height: 100%; width: 100%; margin: 0; font-family: sans-serif;
            display: flex; flex-direction: column;
        }
        #map { flex-grow: 1; }
        #bottombar { display: none; } /* Hide the bottom bar */
    
        /* NEW CSS for control alignment */
        .maplibregl-ctrl-bottom-left {
            padding-left: 10px;
            padding-bottom: 30px;
            display: flex;
            flex-direction: row; /* Arrange controls in a horizontal line */
            align-items: flex-end; /* Align the bottom edges of the controls */
        }
        .maplibregl-ctrl-bottom-left .maplibregl-ctrl {
            clear: none; /* Prevent controls from forcing a new line */
            margin: 0 10px 10px 0; /* Add space to the right and bottom of each control */
        }
        /* END NEW CSS */
    
        /* KML Upload Button */
        .maplibregl-ctrl-kml-upload {
            background-color: white; border-radius: 4px; box-shadow: 0 0 0 2px rgba(0,0,0,.1);
            padding: 4px 10px; cursor: pointer; position: relative; display: flex; align-items: center;
        }
        .maplibregl-ctrl-kml-upload input {
            position: absolute; width: 100%; height: 100%; top: 0; left: 0; opacity: 0; cursor: pointer;
        }
        .maplibregl-ctrl-kml-upload .label { font-size: 12px; color: #333; }
    
        /* Grid Toggle Control */
        .maplibregl-ctrl-grid-toggle {
            background-color: white; border-radius: 15px; box-shadow: 0 0 0 2px rgba(0,0,0,.1);
            display: flex; cursor: pointer;
        }
        .maplibregl-ctrl-grid-toggle span {
            padding: 4px 10px; font-size: 12px; color: #333;
        }
        .maplibregl-ctrl-grid-toggle span:first-child {
            border-top-left-radius: 14px; border-bottom-left-radius: 14px;
            border-right: 1px solid #ccc;
        }
        .maplibregl-ctrl-grid-toggle span:last-child {
            border-top-right-radius: 14px; border-bottom-right-radius: 14px;
        }
        .maplibregl-ctrl-grid-toggle span.active {
            background-color: #3386c0; color: white; font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="bottombar"></div>

<script>
    // --- Configuration ---
    const MIN_GRID_ZOOM = 11;
    const MAPTILER_API_KEY = "5xvmU2oirJBc6iLf4Q2Y";
    let gridDisplayZoomLevel = 14;

    // --- Map Initialization ---
    const map = new maplibregl.Map({
        container: 'map',
        style: `https://api.maptiler.com/maps/streets-v2/style.json?key=${MAPTILER_API_KEY}`,
        center: [6.149183, 45.899952], // Default center Annecy
        zoom: 12
    });

    // --- Add Map Controls ---
    map.addControl(new maplibregl.NavigationControl(), 'top-left');
    map.addControl(new maplibregl.ScaleControl({ unit: 'metric' }), 'bottom-right');
    map.addControl(new maplibregl.GeolocateControl(), 'top-left');

    // --- Calculation Functions ---
    function deg2rad(d) { return d * Math.PI / 180; }
    function rad2deg(r) { return r * 180 / Math.PI; }
    function yTileToLatDeg(y, z) { const n = Math.pow(2, z); const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))); return rad2deg(latRad); }
    function xTileToLonDeg(x, z) { const n = Math.pow(2, z); return x / n * 360.0 - 180.0; }
    function lonDegToXTile(lon, z) { const n = Math.pow(2, z); return Math.floor((lon + 180) / 360 * n); }
    function latDegToYTile(lat, z) { const n = Math.pow(2, z); const latClamped = Math.max(-85.0511, Math.min(85.0511, lat)); const latRad = deg2rad(latClamped); return Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n); }

    // --- Drawing Functions ---
    function drawGrid() {
        if (map.getZoom() < MIN_GRID_ZOOM - 0.5) {
            if (map.getLayer('grid-layer')) map.setLayoutProperty('grid-layer', 'visibility', 'none');
            return;
        }

        const bounds = map.getBounds();
        const west = bounds.getWest(), east = bounds.getEast(), south = bounds.getSouth(), north = bounds.getNorth();
        const features = [];
        const tileCountZ = Math.pow(2, gridDisplayZoomLevel);
        const degPerTileLonZ = 360 / tileCountZ;
        const kMinLon = Math.floor((west + 180) / degPerTileLonZ);
        const kMaxLon = Math.ceil((east + 180) / degPerTileLonZ);
        for (let k = kMinLon; k <= kMaxLon; k++) {
            const lon = xTileToLonDeg(k, gridDisplayZoomLevel);
            features.push({ type: 'Feature', geometry: { type: 'LineString', coordinates: [[lon, south], [lon, north]] } });
        }
        const yMin = latDegToYTile(north, gridDisplayZoomLevel);
        const yMax = latDegToYTile(south, gridDisplayZoomLevel);
        for (let y = yMin; y <= yMax + 1; y++) {
            const lat = yTileToLatDeg(y, gridDisplayZoomLevel);
            features.push({ type: 'Feature', geometry: { type: 'LineString', coordinates: [[west, lat], [east, lat]] } });
        }
        
        const source = map.getSource('grid-source');
        if (source) {
            source.setData({ type: 'FeatureCollection', features: features });
        } else {
            map.addSource('grid-source', { type: 'geojson', data: { type: 'FeatureCollection', features: features } });
            map.addLayer({
                id: 'grid-layer',
                type: 'line',
                source: 'grid-source',
                paint: { 'line-color': '#FF0000', 'line-width': 0.5 }
            });
        }
        if (map.getLayer('grid-layer')) map.setLayoutProperty('grid-layer', 'visibility', 'visible');
    }

    function drawKmlOverlay(geojsonData) {
        if (map.getLayer('kml-layer')) map.removeLayer('kml-layer');
        if (map.getSource('kml-source')) map.removeSource('kml-source');

        map.addSource('kml-source', {
            type: 'geojson',
            data: geojsonData
        });
        map.addLayer({
            id: 'kml-layer',
            type: 'fill',
            source: 'kml-source',
            paint: {
                'fill-color': '#28a745', // Green-ish color
                'fill-opacity': 0.15,
                'fill-outline-color': '#1a6e2c' // Darker green outline
            }
        }, 'grid-layer'); // Ensures the KML is drawn UNDER the grid
    }

    // --- KML Parsing ---
    function parseKML(kmlText) {
        const parser = new DOMParser();
        const kmlDoc = parser.parseFromString(kmlText, "text/xml");
        const features = [];
        const polygons = kmlDoc.getElementsByTagName('Polygon');
        let globalBounds = new maplibregl.LngLatBounds();

        for (const poly of polygons) {
            const allRings = [];

            // Get the main outline
            const outerBoundary = poly.getElementsByTagName('outerBoundaryIs')[0];
            if (!outerBoundary) continue;
            const outerCoordsText = outerBoundary.getElementsByTagName('coordinates')[0]?.textContent.trim();
            if (!outerCoordsText) continue;
            const outerRing = outerCoordsText.split(/\s+/).map(p => {
                const parts = p.split(',');
                const lon = parseFloat(parts[0]);
                const lat = parseFloat(parts[1]);
                globalBounds.extend([lon, lat]);
                return [lon, lat];
            });
            allRings.push(outerRing);

            // **FIX**: Get all the "holes" inside the main polygon
            const innerBoundaries = poly.getElementsByTagName('innerBoundaryIs');
            for (const inner of innerBoundaries) {
                const innerCoordsText = inner.getElementsByTagName('coordinates')[0]?.textContent.trim();
                if (innerCoordsText) {
                    const innerRing = innerCoordsText.split(/\s+/).map(p => {
                        const parts = p.split(',');
                        return [parseFloat(parts[0]), parseFloat(parts[1])];
                    });
                    allRings.push(innerRing);
                }
            }
            features.push({ type: 'Feature', geometry: { type: 'Polygon', coordinates: allRings } });
        }

        if (features.length > 0) {
            drawKmlOverlay({ type: 'FeatureCollection', features: features });
            map.fitBounds(globalBounds, { padding: 50, maxZoom: 15 });
        } else {
            alert("No valid polygons found in the KML file.");
        }
    }

    // --- Custom Map Controls ---
    class KmlUploadControl {
        onAdd() {
            this._container = document.createElement('div');
            this._container.className = 'maplibregl-ctrl maplibregl-ctrl-group maplibregl-ctrl-kml-upload';
            this._container.innerHTML = `<span class="label">NEW! Upload KML from squadrats.com</span><input type="file" accept=".kml">`;
            this._container.querySelector('input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (re) => parseKML(re.target.result);
                    reader.readAsText(file);
                }
                e.target.value = '';
            });
            return this._container;
        } onRemove() {}
    }
    class GridToggleControl {
        onAdd() {
            this._container = document.createElement('div');
            this._container.className = 'maplibregl-ctrl maplibregl-ctrl-group maplibregl-ctrl-grid-toggle';
            this.spans = [document.createElement('span'), document.createElement('span')];
            this.spans[0].textContent = 'Tiles/Squadrats'; this.spans[1].textContent = 'Squadratinhos';
            this.spans[0].addEventListener('click', () => this.setGridZoom(14));
            this.spans[1].addEventListener('click', () => this.setGridZoom(17));
            this._container.append(this.spans[0], this.spans[1]);
            this.updateActiveState();
            return this._container;
        }
        setGridZoom(z) { if (gridDisplayZoomLevel !== z) { gridDisplayZoomLevel = z; this.updateActiveState(); drawGrid(); } }
        updateActiveState() { this.spans[0].classList.toggle('active', gridDisplayZoomLevel === 14); this.spans[1].classList.toggle('active', gridDisplayZoomLevel === 17); }
        onRemove() {}
    }
    
    map.addControl(new KmlUploadControl(), 'bottom-left');
    map.addControl(new GridToggleControl(), 'bottom-left');
    
    // --- Map Event Listeners ---
    map.on('load', drawGrid);
    map.on('moveend', drawGrid);
    map.on('zoomend', drawGrid);
    map.on('click', (e) => {
        // Dummy click handler for now, can be re-enabled later
        console.log(`Clicked on tile: z${gridDisplayZoomLevel}-${lonDegToXTile(e.lngLat.lng, gridDisplayZoomLevel)}-${latDegToYTile(e.lngLat.lat, gridDisplayZoomLevel)}`);
    });
</script>
</body>
</html>
